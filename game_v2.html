<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ARPG Prototype</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Arial', sans-serif;
            color: white;
            user-select: none;
        }

        canvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: auto;
        }

        .bar-container {
            width: 300px;
            height: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #444;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        .bar-fill {
            height: 100%;
            transition: width 0.2s;
        }

        #hp-bar-fill {
            background: linear-gradient(90deg, #ff4444, #cc0000);
            width: 100%;
        }

        #xp-bar-fill {
            background: linear-gradient(90deg, #44ff44, #00cc00);
            width: 0%;
        }

        #energy-bar-fill {
            background: linear-gradient(90deg, #4444ff, #0000cc);
            width: 100%;
        }

        .bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
            z-index: 1;
        }

        #skill-bar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            pointer-events: auto;
        }

        .skill-slot {
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #666;
            border-radius: 8px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: #fff;
            overflow: hidden;
        }

        .skill-slot.active {
            border-color: #ffff00;
            box-shadow: 0 0 10px #ffff00;
        }

        .skill-key {
            position: absolute;
            top: 2px;
            left: 4px;
            font-size: 10px;
            color: #aaa;
        }

        .skill-cd {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0%;
            background: rgba(0, 0, 0, 0.8);
            transition: height 0.1s linear;
        }

        #statPanel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 800px;
            height: 600px;
            background: rgba(20, 20, 30, 0.95);
            border: 2px solid #666;
            border-radius: 10px;
            display: none;
            flex-direction: column;
            padding: 20px;
            pointer-events: auto;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            z-index: 100;
        }

        #merchantPanel,
        #questPanel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px;
            height: 400px;
            background: rgba(20, 20, 30, 0.95);
            border: 2px solid #666;
            border-radius: 10px;
            display: none;
            flex-direction: column;
            padding: 20px;
            pointer-events: auto;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            z-index: 100;
            color: #fff;
        }

        .merchant-items {
            display: grid;
            cursor: pointer;
            transition: background 0.2s;
        }

        .merchant-item:hover {
            background: #444;
        }

        .close-btn {
            margin-top: 20px;
            padding: 10px;
            background: #d32f2f;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 5px;
            font-weight: bold;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        .panel-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .tab-btn {
            padding: 10px 20px;
            background: #333;
            border: none;
            color: #aaa;
            cursor: pointer;
            font-weight: bold;
            border-radius: 5px;
        }

        .tab-btn.active {
            background: #555;
            color: #fff;
            box-shadow: 0 0 5px #555;
        }

        .tab-content {
            display: none;
            flex: 1;
            overflow-y: auto;
        }

        .tab-content.active {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
        }

        .stat-btn {
            background: #4CAF50;
            border: none;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
            margin-left: 10px;
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
        }

        .inv-item {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #444;
            padding: 10px;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .inv-name {
            font-weight: bold;
        }

        .inv-btn {
            background: #444;
            border: none;
            color: white;
            padding: 5px;
            cursor: pointer;
            margin-top: auto;
        }

        .inv-btn:hover {
            background: #666;
        }

        .equip-slots {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            justify-content: center;
        }

        .equip-slot {
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px dashed #666;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            color: #666;
            position: relative;
        }

        .unequip-btn {
            position: absolute;
            top: -5px;
            right: -5px;
            background: red;
            border: none;
            color: white;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .skill-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
        }

        .skill-card {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #444;
            padding: 10px;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            gap: 5px;
            opacity: 0.5;
        }

        .skill-card.unlocked {
            opacity: 1;
            border-color: #ffff00;
        }

        .skill-icon {
            font-size: 30px;
            margin-bottom: 5px;
        }

        .skill-btn {
            background: #444;
            border: none;
            color: white;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 3px;
        }

        .skill-btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .talent-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .talent-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }

        .talent-btn {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
        }

        .talent-btn.disabled {
            background: #444;
            cursor: not-allowed;
        }

        #gameOver {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: red;
            font-size: 48px;
            font-weight: bold;
            z-index: 200;
        }

        #gameOver button {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 24px;
            cursor: pointer;
        }

        .inv-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }

        .inv-tab-btn {
            padding: 5px 10px;
            background: #222;
            border: 1px solid #444;
            color: #888;
            cursor: pointer;
            font-size: 12px;
            border-radius: 3px;
        }

        .inv-tab-btn.active {
            background: #444;
            color: #fff;
            border-color: #666;
        }

        #itemTooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #666;
            padding: 10px;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
            z-index: 2005;
        }

        .tooltip-stat {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            margin-bottom: 2px;
        }

        .stat-better {
            color: #00ff00;
        }

        .stat-worse {
            color: #ff0000;
        }

        #tutorialPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 30px;
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 2000;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            pointer-events: auto;
        }

        .tutorial-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
            font-size: 20px;
            color: #fff;
        }

        .key {
            background: #333;
            border: 1px solid #666;
            border-radius: 4px;
            padding: 2px 8px;
            font-family: monospace;
            font-weight: bold;
            color: #ffff00;
            box-shadow: 0 2px 0 #000;
        }
    </style>
</head>

<body>
    <div id="ui-layer">
        <div id="hud">
            <div class="bar-container">
                <div id="hp-bar-fill" class="bar-fill"></div>
                <div id="hp-text" class="bar-text">100/100</div>
            </div>
            <div class="bar-container">
                <div id="xp-bar-fill" class="bar-fill"></div>
                <div class="bar-text">XP</div>
            </div>
            <div class="bar-container" style="width: 200px;">
                <div id="energy-bar-fill" class="bar-fill"></div>
                <div class="bar-text">Energy</div>
            </div>
        </div>
        <div id="skill-bar">
            <div class="skill-slot" id="skill-1"><span class="skill-key">1</span>?<div id="cd-1" class="skill-cd"></div>
            </div>
            <div class="skill-slot" id="skill-2"><span class="skill-key">2</span>??<div id="cd-2" class="skill-cd">
                </div>
            </div>
            <div class="skill-slot" id="skill-3"><span class="skill-key">3</span>??<div id="cd-3" class="skill-cd">
                </div>
            </div>
            <div class="skill-slot" id="skill-4"><span class="skill-key">4</span>??<div id="cd-4" class="skill-cd">
                </div>
            </div>
            <div class="skill-slot" id="skill-5"><span class="skill-key">5</span>??<div id="cd-5" class="skill-cd">
                </div>
            </div>
            <div class="skill-slot" id="skill-space" style="border-color: #f0f;"><span class="skill-key">SPC</span>??
                <div id="cd-space" class="skill-cd"></div>
            </div>
        </div>
        <div id="gold-display"
            style="position: absolute; top: 20px; right: 20px; font-size: 24px; color: #ffd700; font-weight: bold; text-shadow: 2px 2px 0 #000;">
            GOLD: <span id="playerGold">0</span>
        </div>
        <div id="quest-display"
            style="position: absolute; top: 60px; right: 20px; width: 250px; background: rgba(0,0,0,0.7); padding: 10px; border: 2px solid #aaa; border-radius: 5px;">
            <div style="color: #fff; font-weight: bold; margin-bottom: 5px;">CURRENT QUEST</div>
            <div id="quest-desc" style="color: #ddd; font-size: 14px;">Loading...</div>
            <div style="width: 100%; height: 10px; background: #333; margin-top: 5px;">
                <div id="quest-bar" style="width: 0%; height: 100%; background: #00ff00; transition: width 0.5s;"></div>
            </div>
        </div>

        <div id="statPanel">
            <div class="panel-header">
                <h2>Character Menu</h2>
                <button onclick="toggleStats()"
                    style="background:none;border:none;color:white;font-size:20px;">X</button>
            </div>
            <div class="panel-tabs">
                <button class="tab-btn active" onclick="switchTab('stats')">Stats & Equip</button>
                <button class="tab-btn" onclick="switchTab('skills')">Skills</button>
                <button class="tab-btn" onclick="switchTab('talents')">Talents</button>
            </div>
            <div id="panel-stats" class="tab-content active">
                <div class="equip-slots">
                    <div class="equip-slot" id="eq-weapon">Weapon</div>
                    <div class="equip-slot" id="eq-armor">Armor</div>
                    <div class="equip-slot" id="eq-accessory">Accessory</div>
                </div>
                <div class="stats-grid">
                    <div class="stat-row"><span>Level: </span><span id="playerLevel">1</span></div>
                    <div class="stat-row"><span>XP: </span><span id="playerXP">0/100</span></div>
                    <div class="stat-row"><span>HP: </span><span id="playerHP">100/100</span></div>
                    <div class="stat-row"><span>Energy: </span><span id="playerEnergy">100/100</span></div>
                    <div class="stat-row"><span>Attack: </span><span id="playerAttack">10</span><button class="stat-btn"
                            onclick="increaseStat('attack')">+</button></div>
                    <div class="stat-row"><span>Speed: </span><span id="playerSpeed">5</span><button class="stat-btn"
                            onclick="increaseStat('speed')">+</button></div>
                    <div class="stat-row"><span>Defense: </span><span id="playerDefense">0</span><button
                            class="stat-btn" onclick="increaseStat('defense')">+</button></div>
                    <div class="stat-row"><span>Crit Rate: </span><span id="playerCritRate">5%</span><button
                            class="stat-btn" onclick="increaseStat('critRate')">+</button></div>
                    <div class="stat-row"><span>Crit Dmg: </span><span id="playerCritDamage">150%</span><button
                            class="stat-btn" onclick="increaseStat('critDamage')">+</button></div>
                    <div class="stat-row"><span>Max HP: </span><span id="playerMaxHp">100</span><button class="stat-btn"
                            onclick="increaseStat('maxHp')">+</button></div>
                </div>
                <div id="statButtons" style="margin-top: 10px; color: #ffff00;">Points Available: <span
                        id="statPoints">0</span></div>
                <h3 style="margin-top: 20px; border-bottom: 1px solid #444;">Inventory</h3>
                <div class="inv-tabs">
                    <button class="inv-tab-btn active" onclick="switchInventoryTab('all')">All</button>
                    <button class="inv-tab-btn" onclick="switchInventoryTab('weapon')">Weapons</button>
                    <button class="inv-tab-btn" onclick="switchInventoryTab('armor')">Armor</button>
                    <button class="inv-tab-btn" onclick="switchInventoryTab('accessory')">Accessories</button>
                    <button class="inv-tab-btn" onclick="switchInventoryTab('material')">Materials</button>
                </div>
                <div id="inventoryList" class="inventory-grid"><!-- Items generated by JS --></div>
            </div>
            <div id="panel-skills" class="tab-content">
                <div style="width: 100%;">
                    <div class="stat-row"><span>Skill Points: </span><span id="skillPoints"
                            style="color: #ffff00;">0</span></div>
                    <div id="skillGrid" class="skill-grid"><!-- Skills generated by JS --></div>
                </div>
            </div>
            <div id="panel-talents" class="tab-content">
                <div style="width: 100%;">
                    <div class="stat-row"><span>Talent Points: </span><span id="talentPoints"
                            style="color: #ffff00;">0</span></div>
                    <div id="talentList" class="talent-list"><!-- Talents generated by JS --></div>
                </div>
            </div>
        </div>

        <div id="merchantPanel">
            <div class="panel-header">
                <h2 style="color:#ffd700; margin:0;">Merchant</h2>
                <button onclick="toggleMerchant()" class="close-btn" style="margin-top:0;">X</button>
            </div>
            <div style="margin-bottom:20px; color:#ffd700; font-size:18px;">Your Gold: <span id="merchantGold">50
                    G</span></div>
            <div class="merchant-items" style="display:flex; flex-direction:column; gap:10px;">
                <div class="merchant-item" onclick="buyItem('potion')">
                    <span style="font-size: 24px;">🍷</span>
                    <span class="inv-name">Health Potion</span>
                    <span style="color: #ffd700;">50 G</span>
                </div>
                <div class="merchant-item" onclick="buyItem('weapon')">
                    <span style="font-size: 24px;">⚔️</span>
                    <span class="inv-name">Random Weapon</span>
                    <span style="color: #ffd700;">200 G</span>
                </div>
                <div class="merchant-item" onclick="buyItem('armor')">
                    <span style="font-size: 24px;">🛡️</span>
                    <span class="inv-name">Random Armor</span>
                    <span style="color: #ffd700;">150 G</span>
                </div>
                <div class="merchant-item" onclick="buyItem('accessory')">
                    <span style="font-size: 24px;">💍</span>
                    <span class="inv-name">Random Accessory</span>
                    <span style="color: #ffd700;">150 G</span>
                </div>
            </div>
        </div>
    </div>




    </div>
    <div id="questBoard"
        style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); width:600px; max-height:500px; background:rgba(0,0,0,0.95); border:2px solid #ffd700; border-radius:10px; flex-direction:column; padding:20px; z-index:100; overflow-y:auto;">
        <div class="panel-header"
            style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
            <h2 style="color:#ffd700; margin:0;">Mercenary Board</h2>
            <button onclick="toggleQuest()" class="close-btn"
                style="background:none; border:none; color:#fff; font-size:20px; cursor:pointer;">X</button>
        </div>
        <div id="questList" style="display:flex; flex-direction:column; gap:10px;">
            <!-- Quests generated by JS -->
        </div>
    </div>

    <!-- Quest Log (Player 'Q' Menu) -->
    <div id="questLog"
        style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); width:500px; max-height:500px; background:rgba(0,0,0,0.95); border:2px solid #0088ff; border-radius:10px; padding:20px; z-index:100; overflow-y:auto;">
        <div class="panel-header"
            style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
            <h2 style="color:#0088ff; margin:0;">Quest Log (<span id="questCount">0</span>/3)</h2>
            <button onclick="toggleQuestLog()" class="close-btn"
                style="background:none; border:none; color:#fff; font-size:20px; cursor:pointer;">X</button>
        </div>
        <div id="activeQuestList" style="display:flex; flex-direction:column; gap:10px;">
            <!-- Active Quests generated by JS -->
        </div>
    </div>

    <!-- HUD Quest Tracker -->
    <div id="questHUD"
        style="display:none; position:absolute; right:20px; top:150px; width:200px; background:rgba(0,0,0,0.5); padding:10px; border-radius:5px; z-index:90;">
        <h4 style="color:#ffd700; margin-top:0; margin-bottom:5px;">Current Quests</h4>
        <div id="hudQuestList" style="font-size:12px; color:#fff;"></div>
    </div>

    <div id="craftingPanel"
        style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); width:400px; height:500px; background:rgba(0,0,0,0.9); border:2px solid #ff8800; border-radius:10px; flex-direction:column; padding:20px; z-index:100;">
        <div class="panel-header">
            <h2 style="color:#ff8800;">Crafting Station</h2>
            <button onclick="toggleCrafting()" class="close-btn" style="margin-top:0;">X</button>
        </div>
        <div id="craftingList"
            style="flex:1; overflow-y:auto; display:flex; flex-direction:column; gap:10px; margin-top:10px;">
            <!-- Recipes generated by JS -->
        </div>
    </div>
    <div id="itemTooltip"></div>
    <div id="tutorialPanel">
        <h2 style=" color: #00ffff; margin-bottom: 20px;">CONTROLS</h2>
        <div class="tutorial-row"><span class="key">W</span><span class="key">A</span><span class="key">S</span><span
                class="key">D</span> <span>Move</span></div>
        <div class="tutorial-row"><span class="key">Space</span> / <span class="key">Click</span>
            <span>Attack</span>
        </div>
        <div class="tutorial-row"><span class="key">E</span> <span>Interact (Portal/NPC/Chest)</span></div>
        <div class="tutorial-row"><span class="key">1</span>-<span class="key">5</span> <span>Skills</span></div>
        <div class="tutorial-row"><span class="key">C</span> <span>Character Menu</span></div>
        <div class="tutorial-row"><span class="key">Q</span> <span>Quest Log</span></div>
        <button class="inv-btn" style="margin-top: 20px; font-size: 18px; padding: 10px 30px;"
            onclick="closeTutorial()">GOT IT!</button>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div id="gameOver">
        <h2>GAME OVER</h2>
        <button onclick="resetGame()">TRY AGAIN</button>
    </div>
    <script src="Player.js"></script>
    <script src="Enemy.js"></script>
    <script>
        window.onerror = function (msg, url, lineNo, columnNo, error) {
            alert('Error: ' + msg + '\nLine: ' + lineNo + '\nColumn: ' + columnNo + '\nStack: ' + (error ? error.stack : 'N/A'));
            return false;
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const TILE_SIZE = 64;
        const MAP_SIZE = 64;

        let player;
        let enemies = [];
        const ENEMY_COUNT = 50;
        let bullets = [];
        let items = [];
        let effects = [];
        let chests = [];
        let currentInventoryTab = 'all';

        // Global Variables for Town System
        let currentMapType = 'town'; // 'town' or 'dungeon'
        let npcs = [];
        let decorations = [];
        let lastDungeonStage = 1; // Saved stage for return portal
        let returnPortalOpen = false; // Is return portal active?

        // Quest System Data
        let availableQuests = [];
        let activeQuests = []; // Max 3
        const MAX_ACTIVE_QUESTS = 3;

        class Quest {
            constructor(id, type, targetType, targetName, amount, difficulty) {
                this.id = id;
                this.type = type; // 'kill', 'collect'
                this.targetType = targetType; // Enemy ID or Item Name/Type
                this.targetName = targetName;
                this.amount = amount;
                this.current = 0;
                this.difficulty = difficulty; // 1-5
                this.status = 'active'; // 'active', 'completed'
                this.reward = this.generateReward(difficulty);
            }

            generateReward(diff) {
                const type = Math.random() < 0.7 ? 'gold' : 'item';
                if (type === 'gold') {
                    return { type: 'gold', value: diff * 100 + Math.floor(Math.random() * 50) };
                } else {
                    // Simple item reward logic (e.g. materials or random equip)
                    return { type: 'item', value: 1, itemName: 'Random Loot' }; // Placeholder
                }
            }
        }

        class NPC {
            constructor(x, y, type, name, color) {
                this.x = x;
                this.y = y;
                this.type = type; // 'merchant', 'quest'
                this.name = name;
                this.color = color;
                this.interactionRadius = 2.0;
                this.vx = 0;
                this.vy = 0;
                this.moveTimer = Math.floor(Math.random() * 100);
            }

            draw(ctx, screenX, screenY) {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(screenX, screenY - 20, 10, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#fff';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.name, screenX, screenY - 40);

                // Interaction prompt
                const dist = Math.sqrt((player.x - this.x) ** 2 + (player.y - this.y) ** 2);
                if (dist < this.interactionRadius) {
                    ctx.fillStyle = '#ffff00';
                    ctx.fillText("Press 'E'", screenX, screenY - 55);
                }
            }

            interact() {
                if (this.type === 'merchant') {
                    toggleMerchant();
                } else if (this.type === 'quest') {
                    toggleQuest();
                } else if (this.type === 'craftsman') {
                    toggleCrafting();
                }
            }

            update() {
                if (this.type === 'villager') {
                    this.moveTimer--;
                    if (this.moveTimer <= 0) {
                        // Change state
                        if (Math.random() < 0.4) {
                            // Walk
                            const angle = Math.random() * Math.PI * 2;
                            this.vx = Math.cos(angle) * 0.02; // Further reduced speed from 0.05 to 0.02
                            this.vy = Math.sin(angle) * 0.02;
                            this.moveTimer = 60 + Math.random() * 120; // Move for 1-3 seconds
                        } else {
                            // Idle
                            this.vx = 0;
                            this.vy = 0;
                            this.moveTimer = 30 + Math.random() * 90; // Idle for 0.5-2 seconds
                        }
                    }

                    if (this.vx !== 0 || this.vy !== 0) {
                        const nextX = this.x + this.vx;
                        const nextY = this.y + this.vy;

                        // Check collision
                        if (!isSolid(nextX, nextY) && Math.sqrt((nextX - player.x) ** 2 + (nextY - player.y) ** 2) > 1) {
                            this.x = nextX;
                            this.y = nextY;
                        } else {
                            // Hit wall, stop and reset timer to pick new direction sooner
                            this.vx = 0;
                            this.vy = 0;
                            this.moveTimer = 0;
                        }
                    }
                }
            }
        }

        function toIso(x, y) {
            return {
                x: (x - y) * TILE_SIZE / 2,
                y: (x + y) * TILE_SIZE / 4
            };
        }

        function isSolid(x, y) {
            let gridX = Math.floor(x);
            let gridY = Math.floor(y);
            if (gridX < 0 || gridX >= MAP_SIZE || gridY < 0 || gridY >= MAP_SIZE) return true;
            return map[gridY][gridX] === 1;
        }

        function generateMap() {
            map = [];
            explored = [];

            npcs = []; // Clear NPCs
            decorations = []; // Clear Decorations
            chests = []; // Clear Chests

            if (currentMapType === 'town') {
                // Generate Town (Safe Zone)
                for (let y = 0; y < MAP_SIZE; y++) {
                    let row = [];
                    let expRow = [];
                    for (let x = 0; x < MAP_SIZE; x++) {
                        // Walls on edges
                        if (x === 0 || x === MAP_SIZE - 1 || y === 0 || y === MAP_SIZE - 1) {
                            row.push(1);
                        } else {
                            row.push(0); // Open floor
                        }
                        expRow.push(true); // Town is fully explored
                    }
                    map.push(row);
                    explored.push(expRow);
                }

                // Spawn Player in Center
                player.x = MAP_SIZE / 2 + 0.5;
                player.y = MAP_SIZE / 2 + 0.5;

                // Add Town Decorations
                // Fountain in center
                decorations.push({ x: player.x, y: player.y - 3, type: 'fountain' });

                // Trees around the edges
                for (let i = 0; i < 20; i++) {
                    let tx = Math.floor(Math.random() * (MAP_SIZE - 4)) + 2;
                    let ty = Math.floor(Math.random() * (MAP_SIZE - 4)) + 2;
                    // Keep away from center
                    if (Math.sqrt((tx - player.x) ** 2 + (ty - player.y) ** 2) > 8) {
                        decorations.push({ x: tx, y: ty, type: 'tree' });
                    }
                }

                // Flowers randomly
                for (let i = 0; i < 50; i++) {
                    let fx = Math.floor(Math.random() * (MAP_SIZE - 2)) + 1;
                    let fy = Math.floor(Math.random() * (MAP_SIZE - 2)) + 1;
                    if (map[fy][fx] === 0) {
                        decorations.push({ x: fx, y: fy, type: 'flower' });
                    }
                }

                // Spawn NPCs
                npcs.push(new NPC(player.x - 5, player.y - 2, 'merchant', 'Merchant', '#00ff00'));

                npcs.push(new NPC(player.x + 5, player.y - 2, 'quest', 'Quest Giver', '#ffff00'));
                npcs.push(new NPC(player.x, player.y - 5, 'craftsman', 'Craftsman', '#ff8800'));

                // Spawn Ambient Villagers
                for (let i = 0; i < 10; i++) {
                    let vx, vy;
                    do {
                        vx = Math.floor(Math.random() * (MAP_SIZE - 4)) + 2;
                        vy = Math.floor(Math.random() * (MAP_SIZE - 4)) + 2;
                    } while (map[vy][vx] === 1 || Math.sqrt((vx - player.x) ** 2 + (vy - player.y) ** 2) < 5);

                    npcs.push(new NPC(vx, vy, 'villager', 'Villager', '#cccccc'));
                }
                // Spawn Portal to Dungeon
                portal = { x: player.x, y: player.y - 8, active: true }; // Always active in town

            } else {
                // Generate Dungeon
                for (let y = 0; y < MAP_SIZE; y++) {
                    let row = [];
                    let expRow = [];
                    for (let x = 0; x < MAP_SIZE; x++) {
                        if (x === 0 || x === MAP_SIZE - 1 || y === 0 || y === MAP_SIZE - 1) {
                            row.push(1);
                        } else {
                            row.push(Math.random() < 0.38 ? 1 : 0);
                        }
                        expRow.push(false);
                    }
                    map.push(row);
                    explored.push(expRow);
                }

                // Cellular Automata
                for (let i = 0; i < 5; i++) {
                    let newMap = JSON.parse(JSON.stringify(map));
                    for (let y = 1; y < MAP_SIZE - 1; y++) {
                        for (let x = 1; x < MAP_SIZE - 1; x++) {
                            let neighbors = 0;
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dx = -1; dx <= 1; dx++) {
                                    if (map[y + dy][x + dx] === 1) neighbors++;
                                }
                            }
                            if (neighbors > 4) newMap[y][x] = 1;
                            else if (neighbors < 4) newMap[y][x] = 0;
                        }
                    }
                    map = newMap;
                }

                // Ensure connectivity (Simplified)
                let regions = [];
                let visited = Array(MAP_SIZE).fill().map(() => Array(MAP_SIZE).fill(false));

                for (let y = 1; y < MAP_SIZE - 1; y++) {
                    for (let x = 1; x < MAP_SIZE - 1; x++) {
                        if (map[y][x] === 0 && !visited[y][x]) {
                            let region = [];
                            let stack = [{ x, y }];
                            visited[y][x] = true;
                            while (stack.length > 0) {
                                let p = stack.pop();
                                region.push(p);
                                [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dx, dy]) => {
                                    let nx = p.x + dx;
                                    let ny = p.y + dy;
                                    if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE && map[ny][nx] === 0 && !visited[ny][nx]) {
                                        visited[ny][nx] = true;
                                        stack.push({ x: nx, y: ny });
                                    }
                                });
                            }
                            regions.push(region);
                        }
                    }
                }

                if (regions.length > 0) {
                    regions.sort((a, b) => b.length - a.length);
                    for (let i = 1; i < regions.length; i++) {
                        regions[i].forEach(p => map[p.y][p.x] = 1);
                    }
                    let spawn = regions[0][Math.floor(Math.random() * regions[0].length)];
                    player.x = spawn.x + 0.5;
                    player.y = spawn.y + 0.5;
                } else {
                    player.x = MAP_SIZE / 2 + 0.5;
                    player.y = MAP_SIZE / 2 + 0.5;
                    map[Math.floor(player.y)][Math.floor(player.x)] = 0;
                }

                spawnPortal();

                // Spawn Chests
                chests = [];
                for (let i = 0; i < 5; i++) {
                    let valid = false;
                    let attempts = 0;
                    while (!valid && attempts < 50) {
                        let x = Math.floor(Math.random() * (MAP_SIZE - 2)) + 1;
                        let y = Math.floor(Math.random() * (MAP_SIZE - 2)) + 1;
                        if (map[y][x] === 0 && Math.sqrt((x - player.x) ** 2 + (y - player.y) ** 2) > 10) {
                            chests.push({ x, y });
                            valid = true;
                        }
                        attempts++;
                    }
                }
            }
        }

        function spawnPortal() {
            portal = { x: 0, y: 0, active: true }; // Portal is active by default so player can find it
            if (currentMapType === 'town') return; // Portal already set in generateMap

            let valid = false;
            let attempts = 0;
            while (!valid && attempts < 1000) {
                let x = Math.floor(Math.random() * (MAP_SIZE - 2)) + 1;
                let y = Math.floor(Math.random() * (MAP_SIZE - 2)) + 1;
                if (map[y][x] === 0 && Math.sqrt((x - player.x) ** 2 + (y - player.y) ** 2) > 20) {
                    portal.x = x;
                    portal.y = y;
                    valid = true;
                }
                attempts++;
            }
            if (!valid) {
                portal.x = player.x;
                portal.y = player.y;
            }
        }




        function resetGame(keepStage = false) {
            if (!keepStage) {
                stage = 1;
                currentMapType = 'town';
            }

            if (!player) player = new Player(10, 10);

            generateMap();
            prerenderMap();

            enemies = [];
            bullets = [];
            items = [];
            effects = [];
            floatingTexts = [];

            if (currentMapType === 'dungeon') {
                // Spawn Boss (One per dungeon level)
                let bossSpawned = false;
                let bossAttempts = 0;
                while (!bossSpawned && bossAttempts < 100) {
                    let x = Math.floor(Math.random() * (MAP_SIZE - 2)) + 1;
                    let y = Math.floor(Math.random() * (MAP_SIZE - 2)) + 1;
                    if (map[y][x] === 0 && Math.sqrt((x - player.x) ** 2 + (y - player.y) ** 2) > 15) {
                        enemies.push(new Enemy(x, y, stage + 2, true)); // Boss: Higher level, isBoss=true
                        bossSpawned = true;
                    }
                    bossAttempts++;
                }

                // Spawn Elite Enemies (5-10 per map)
                let eliteCount = 5 + Math.floor(Math.random() * 6);
                for (let i = 0; i < eliteCount; i++) {
                    let valid = false;
                    let attempts = 0;
                    while (!valid && attempts < 100) {
                        let x = Math.floor(Math.random() * (MAP_SIZE - 2)) + 1;
                        let y = Math.floor(Math.random() * (MAP_SIZE - 2)) + 1;
                        if (map[y][x] === 0 && Math.sqrt((x - player.x) ** 2 + (y - player.y) ** 2) > 15) {
                            enemies.push(new Enemy(x, y, stage + 1, 'elite')); // Elite: Level = Stage + 1
                            valid = true;
                        }
                        attempts++;
                    }
                }

                // Spawn Enemies only in Dungeon
                for (let i = 0; i < ENEMY_COUNT + stage * 5; i++) {
                    let valid = false;
                    let attempts = 0;
                    while (!valid && attempts < 100) {
                        let x = Math.floor(Math.random() * (MAP_SIZE - 2)) + 1;
                        let y = Math.floor(Math.random() * (MAP_SIZE - 2)) + 1;
                        if (map[y][x] === 0 && Math.sqrt((x - player.x) ** 2 + (y - player.y) ** 2) > 10) {
                            enemies.push(new Enemy(x, y, stage));
                            valid = true;
                        }
                        attempts++;
                    }
                }
                if (typeof generateQuests === 'function') {
                    // Start fresh with quests if desired, or keep existing?
                    // Usually resetGame implies new run. 
                    // Let's just ensure we don't error out.
                    // availableQuests = []; 
                    // activeQuests = []; 
                    // generateQuests(); 
                    // updateQuestBoardUI();
                    // updateQuestLogUI();
                    // updateHUDQuestList();
                    // Actually, if we die in dungeon, we might want to keep quests?
                    // User didn't specify. But resetting game usually resets everything.
                    // For now, let's just NOT call the missing function.
                }
            } else {
                // Town Mode
                // Ensure quest board is ready if we return to town
                if (typeof generateQuests === 'function' && availableQuests.length === 0) {
                    generateQuests();
                }
            }

            updateHUD();
            initSkillBar(); // Fix Skill Icons
            document.getElementById('gameOver').style.display = 'none';
            player.hp = player.stats.maxHp;
        }

        function initSkillBar() {
            // Dynamically set skill icons to avoid encoding issues
            if (player && player.SKILLS) {
                player.SKILLS.forEach((skill, index) => {
                    let id = index + 1;
                    if (index === 5) id = 'space';
                    const slot = document.getElementById(`skill-${id}`);
                    if (slot) {
                        // Keep the key span and cooldown div, just update text node if possible, 
                        // or simpler: rebuild innerHTML
                        const key = slot.querySelector('.skill-key').innerText;
                        slot.innerHTML = `<span class="skill-key">${key}</span>${skill.icon}<div id="cd-${id}" class="skill-cd"></div>`;
                    }
                });
            }
        }
        function closeTutorial() {
            document.getElementById('tutorialPanel').style.display = 'none';
        }

        function update() {
            if (document.getElementById('tutorialPanel').style.display === 'flex') return;
            if (player.hp <= 0) return;

            let dx = 0;
            let dy = 0;

            if (keys['w']) { dx -= 1; dy -= 1; }
            if (keys['s']) { dx += 1; dy += 1; }
            if (keys['a']) { dx -= 1; dy += 1; }
            if (keys['d']) { dx += 1; dy -= 1; }

            player.move(dx, dy, map);

            if (keys[' ']) {
                const initialEnemyCount = enemies.length;
                player.attack(enemies, bullets, effects, items, floatingTexts, spawnItem);
                const killedCount = initialEnemyCount - enemies.length;
                if (killedCount > 0) {
                    // Trigger quest kill update multiple times if multiple kills? 
                    // Or just once? The logic updates 'current' based on count.
                    // My onQuestEvent increments by 1. So I should call it N times.
                    for (let k = 0; k < killedCount; k++) onQuestEvent('kill');
                }
            }

            if (keys['1']) player.useSkill(0, enemies, effects, items, floatingTexts, bullets, map);
            if (keys['2']) player.useSkill(1, enemies, effects, items, floatingTexts, bullets, map);
            if (keys['3']) player.useSkill(2, enemies, effects, items, floatingTexts, bullets, map);
            if (keys['4']) player.useSkill(3, enemies, effects, items, floatingTexts, bullets, map);
            if (keys['5']) player.useSkill(4, enemies, effects, items, floatingTexts, bullets, map);
            if (keys['q'] && !player.qPressed) {
                toggleQuestLog();
                player.qPressed = true;
            } else if (!keys['q']) {
                player.qPressed = false;
            }

            const aimDx = mouseX - canvas.width / 2;
            const aimDy = mouseY - canvas.height / 2;
            player.aimAngle = Math.atan2(aimDy, aimDx);
            player.aimDist = Math.sqrt(aimDx * aimDx + aimDy * aimDy);

            if (mouseDown) {
                if (player.shootTimer <= 0) {
                    player.shoot(mouseX, mouseY, bullets, canvas);
                    player.shootTimer = player.weapon.rate;
                }
            }

            if (keys['c'] && !player.cPressed) {
                toggleStats();
                player.cPressed = true;
            } else if (!keys['c']) {
                player.cPressed = false;
            }

            player.update();
            npcs.forEach(n => n.update());

            const initialCnt = enemies.length;
            enemies.forEach(e => e.update(player, map, bullets, floatingTexts, effects, items, spawnItem, enemies));
            enemies = enemies.filter(e => e.hp > 0);

            // Check indirect kills (bullets/skills)
            const indirectKills = initialCnt - enemies.length;
            if (indirectKills > 0) { // This might double count spacebar kills if I'm not careful. 
                // Spacebar logic above handles direct hits. 
                // Enemy.update handles damage from existing bullets.
                // The spacebar block above only adds logic for 'manual' attack?
                // Actually, player.attack calls activateUltimate which kills enemies.
                // Enemy.update handles bullet collision.
                // We should probably rely on onQuestEvent hooks inside the death logic if possible?
                // But I can't easily inject into Enemy.js right now without another edit.
                // So I'll just check diff here.
                // However, the spacebar block calculates diff immediately.
                // The enemy.update loop calculates diff from bullets.
                // So we can assume any drop in enemy count here is a kill.
                for (let k = 0; k < indirectKills; k++) onQuestEvent('kill');
            }

            bullets.forEach(b => {
                b.x += b.vx;
                b.y += b.vy;
                b.life--;
            });
            bullets = bullets.filter(b => {
                const bx = Math.floor(b.x);
                const by = Math.floor(b.y);
                return b.life > 0 &&
                    bx >= 0 && bx < MAP_SIZE &&
                    by >= 0 && by < MAP_SIZE &&
                    map[by][bx] === 0;
            });

            effects.forEach(e => {
                if (e.type === 'nova') {
                    e.radius += 0.2;
                    e.life--;
                } else if (e.type === 'levelup') {
                    e.radius += 0.1;
                    e.life--;
                } else if (e.type === 'lightning') {
                    e.life--;
                }
            });
            effects = effects.filter(e => e.life > 0);

            items.forEach(item => {
                if (Math.sqrt((player.x - item.x) ** 2 + (player.y - item.y) ** 2) < 1) {
                    if (item.type === 0) {
                        player.hp = Math.min(player.hp + 20, player.stats.maxHp);
                        spawnFloatingText(player.x, player.y, "+20 HP", '#0f0', 20);
                    } else if (item.type === 7) {
                        player.gold += 10;
                        spawnFloatingText(player.x, player.y, "+10 G", '#ffd700', 20);
                    } else if (item.type === 8) { // Material
                        onQuestEvent('collect', 'material');
                        if (player.inventory.length < 20) {
                            player.inventory.push(item);
                            spawnFloatingText(player.x, player.y, item.name, '#fff', 20);
                            updateInventoryUI();
                        }
                    } else {
                        // Equipment
                        if (player.inventory.length < 20) {
                            player.inventory.push(item);
                            spawnFloatingText(player.x, player.y, "ITEM", '#fff', 20);
                            updateInventoryUI();
                        }
                    }
                    item.life = 0;
                }
            });
            items = items.filter(i => i.life > 0);

            // Portal Activation (Dungeon Cleared)
            if (currentMapType === 'dungeon' && !portal.active && enemies.length === 0) {
                portal.active = true;
                spawnFloatingText(portal.x, portal.y, "PORTAL OPEN", '#0ff', 30);
            }

            updateFog();
            updateHUD();

            if (player.hp <= 0) {
                document.getElementById('gameOver').style.display = 'flex';
            }
        }



        const keys = {};
        let mouseX = 0;
        let mouseY = 0;
        let mouseDown = false;

        window.addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; });
        window.addEventListener('mousedown', () => mouseDown = true);
        window.addEventListener('mouseup', () => mouseDown = false);
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        window.addEventListener('keydown', e => {
            keys[e.key] = true;
            if (e.key === 'e' || e.key === 'E') {
                // Check for NPC Interaction
                npcs.forEach(n => {
                    const dist = Math.sqrt((player.x - n.x) ** 2 + (player.y - n.y) ** 2);
                    if (dist < n.interactionRadius) {
                        n.interact();
                    }
                });

                if (portal.active && Math.sqrt((player.x - portal.x) ** 2 + (player.y - portal.y) ** 2) < 2) {
                    if (currentMapType === 'town') {
                        if (returnPortalOpen) {
                            stage = lastDungeonStage; // Return to saved stage
                            console.log("Returning to saved stage: " + stage);
                        } else {
                            currentMapType = 'dungeon';
                            stage = 1;
                        }
                        returnPortalOpen = false; // Consume portal on use (optional, or keep open until new run?)
                        // Let's keep it open until a new run starts or player dies? 
                        // Usually return portals close after use or if you start a new run. 
                        // For now, let's close it on use to prevent abuse or confusion, 
                        // BUT common ARPG design: keep it open so you can go back and forth until you go deeper.
                        // User request: "Use scroll -> Portal appears -> Player uses it -> Returns to floor".
                        // It doesn't specify if it stays or closes. 
                        // To allow selling and returning, we should probably KEEP it open until we leave town to a NEW dungeon or reset.
                        // But wait, if I warp to Dungeon Lv 5, I'm now in Dungeon.
                        // If I use another scroll, I come back.
                        // So 'close on use' effectively means 'close the path FROM town'.
                        // Once in dungeon, if I die or restart, it's gone.
                        // If I walk back to town from dungeon? Wait, there is no walk back.
                        // So interacting with it puts me in Dungeon.
                        // I'll keep returnPortalOpen = false for now to be safe, assuming one-way trip back.
                        // Actually, better: if you return to dungeon, you are in dungeon. The 'return portal' concept is usually 'Town Portal' (Blue) in Diablo.
                        // It stays open as long as you are in town.
                        // Let's set it to false on entry to simulate "taking the portal back". 
                        // If user uses another scroll, a new one opens.
                        returnPortalOpen = false;

                        currentMapType = 'dungeon'; // Ensure type is set
                    } else {
                        stage++; // Next Level
                    }
                    resetGame(true);
                    console.log("Portal interaction: Next Stage/Return");
                }

                // Check for Chests
                const chestIndex = chests.findIndex(c => Math.sqrt((player.x - c.x) ** 2 + (player.y - c.y) ** 2) < 2);
                if (chestIndex !== -1) {
                    const c = chests[chestIndex];
                    chests.splice(chestIndex, 1);
                    spawnFloatingText(player.x, player.y, "Chest Opened!", '#ffd700', 30);
                    // Drop items (1-3 items)
                    const count = Math.floor(Math.random() * 3) + 1;
                    for (let i = 0; i < count; i++) {
                        spawnItem(c.x, c.y);
                    }
                }
            }
        });
        window.addEventListener('keyup', e => keys[e.key] = false);

        let mapCanvas = document.createElement('canvas');
        let mapCtx = mapCanvas.getContext('2d');

        function prerenderMap() {
            mapCanvas.width = MAP_SIZE * TILE_SIZE + 200;
            mapCanvas.height = MAP_SIZE * TILE_SIZE / 2 + 200;
            const offsetX = mapCanvas.width / 2;
            const offsetY = 0;
            mapCtx.clearRect(0, 0, mapCanvas.width, mapCanvas.height);

            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    const iso = toIso(x, y);
                    const screenX = iso.x + offsetX;
                    const screenY = iso.y + offsetY;

                    if (map[y][x] === 1) {
                        mapCtx.fillStyle = '#444';
                        if (currentMapType === 'town') mapCtx.fillStyle = '#666'; // Lighter walls in town
                        mapCtx.beginPath();
                        mapCtx.moveTo(screenX, screenY - 32);
                        mapCtx.lineTo(screenX + 32, screenY - 16);
                        mapCtx.lineTo(screenX, screenY);
                        mapCtx.lineTo(screenX, screenY + 32);
                        mapCtx.lineTo(screenX - 32, screenY + 16);
                        mapCtx.fill();
                        mapCtx.stroke();

                        mapCtx.fillStyle = '#111';
                        mapCtx.beginPath();
                        mapCtx.moveTo(screenX, screenY);
                        mapCtx.lineTo(screenX + 32, screenY - 16);
                        mapCtx.lineTo(screenX + 32, screenY + 16);
                        mapCtx.lineTo(screenX, screenY + 32);
                        mapCtx.fill();
                        mapCtx.stroke();
                    } else {
                        mapCtx.fillStyle = '#222';
                        mapCtx.beginPath();
                        mapCtx.moveTo(screenX, screenY);
                        mapCtx.lineTo(screenX + 32, screenY - 16);
                        mapCtx.lineTo(screenX + 64, screenY);
                        mapCtx.lineTo(screenX + 32, screenY + 16);
                        mapCtx.fill();
                        mapCtx.strokeStyle = '#333';
                        mapCtx.stroke();
                    }
                }
            }
        }

        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const cameraX = canvas.width / 2 - (player.x - player.y) * TILE_SIZE / 2;
            const cameraY = canvas.height / 2 - (player.x + player.y) * TILE_SIZE / 4;

            const mapDrawX = cameraX - mapCanvas.width / 2;
            const mapDrawY = cameraY;
            ctx.drawImage(mapCanvas, mapDrawX, mapDrawY);

            // Draw Unexplored Areas (Fog of War)
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    if (!explored[y][x]) {
                        const iso = toIso(x, y);
                        const screenX = iso.x + cameraX;
                        const screenY = iso.y + cameraY;
                        if (screenX < -TILE_SIZE || screenX > canvas.width + TILE_SIZE || screenY < -TILE_SIZE || screenY > canvas.height + TILE_SIZE) continue;

                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.moveTo(screenX, screenY);
                        ctx.lineTo(screenX + 32, screenY - 16);
                        ctx.lineTo(screenX + 64, screenY);
                        ctx.lineTo(screenX + 32, screenY + 16);
                        ctx.fill();
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                }
            }

            // Draw Portal
            if ((portal.active || currentMapType === 'town') && explored[Math.floor(portal.y)][Math.floor(portal.x)]) {
                const iso = toIso(portal.x, portal.y);
                const screenX = iso.x + cameraX;
                const screenY = iso.y + cameraY;

                // Portal Glow
                const pulse = Math.sin(Date.now() / 200) * 5;
                ctx.fillStyle = currentMapType === 'town' ? '#00ff00' : '#00ffff';
                ctx.beginPath();
                ctx.ellipse(screenX, screenY, 20 + pulse, 10 + pulse / 2, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#fff';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                let portalText = currentMapType === 'town' ? "To Dungeon" : "Next Stage";
                if (currentMapType === 'town' && returnPortalOpen) {
                    portalText = `Return to Lv ${lastDungeonStage}`;
                    ctx.fillStyle = '#00ffff'; // Highlight return portal
                }
                ctx.fillText(portalText, screenX, screenY - 20);
                if (currentMapType === 'town' && returnPortalOpen) ctx.fillStyle = '#fff'; // Reset color

                // Interaction Hint
                if (Math.hypot(player.x - portal.x, player.y - portal.y) < 2) {
                    ctx.fillStyle = '#ffff00';
                    ctx.font = 'bold 14px Arial';
                    ctx.fillText("Press E", screenX, screenY - 40);
                    ctx.fillStyle = '#fff'; // Reset
                }
            }

            // Draw Chests
            // Draw Chests
            chests.forEach(c => {
                if (explored[Math.floor(c.y)][Math.floor(c.x)]) {
                    const iso = toIso(c.x, c.y);
                    const screenX = iso.x + cameraX;
                    const screenY = iso.y + cameraY;
                    ctx.fillStyle = '#ffaa00';
                    ctx.fillRect(screenX - 10, screenY - 20, 20, 20);
                    ctx.strokeStyle = '#fff';
                    ctx.strokeRect(screenX - 10, screenY - 20, 20, 20);

                    // Interaction Hint
                    if (Math.hypot(player.x - c.x, player.y - c.y) < 2) {
                        ctx.fillStyle = '#ffff00';
                        ctx.font = 'bold 14px Arial';
                        ctx.fillText("Press E", screenX, screenY - 30);
                        ctx.fillStyle = '#fff'; // Reset
                    }
                }
            });

            // Draw Decorations (Simple sorting: draw before NPCs/Players if "behind" or simply layer)
            // For true iso depth, we need strict sorting. For now, drawing them here.
            decorations.forEach(d => {
                const iso = toIso(d.x, d.y);
                const screenX = iso.x + cameraX;
                const screenY = iso.y + cameraY;

                if (d.type === 'tree') {
                    // Trunk
                    ctx.fillStyle = '#8b4513';
                    ctx.fillRect(screenX - 2, screenY - 10, 4, 10);
                    // Foliage
                    ctx.fillStyle = '#228b22';
                    ctx.beginPath();
                    ctx.moveTo(screenX, screenY - 40);
                    ctx.lineTo(screenX + 15, screenY - 10);
                    ctx.lineTo(screenX - 15, screenY - 10);
                    ctx.fill();
                } else if (d.type === 'fountain') {
                    // Base
                    ctx.fillStyle = '#888';
                    ctx.beginPath();
                    ctx.ellipse(screenX, screenY, 20, 10, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Water
                    ctx.fillStyle = '#00ffff';
                    ctx.beginPath();
                    ctx.ellipse(screenX, screenY - 5, 15, 7, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Spout
                    ctx.fillStyle = '#00ffff';
                    ctx.fillRect(screenX - 2, screenY - 25, 4, 20);
                } else if (d.type === 'flower') {
                    ctx.fillStyle = ['#ff0000', '#ffff00', '#ff69b4'][Math.floor((d.x + d.y) % 3)];
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            // Draw NPCs
            npcs.forEach(n => {
                const iso = toIso(n.x, n.y);
                n.draw(ctx, iso.x + cameraX, iso.y + cameraY);
            });

            // Draw Items
            items.forEach(item => {
                if (explored[Math.floor(item.y)][Math.floor(item.x)]) {
                    const iso = toIso(item.x, item.y);
                    const screenX = iso.x + cameraX;
                    const screenY = iso.y + cameraY;

                    ctx.fillStyle = item.color;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, 5, 0, Math.PI * 2);
                    ctx.fill();

                    // Simple glow effect for rare items
                    if (item.quality > 1) {
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = item.color;
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    }
                }
            });

            // Draw Enemies
            enemies.forEach(e => {
                if (explored[Math.floor(e.y)][Math.floor(e.x)]) {
                    const iso = toIso(e.x, e.y);
                    e.draw(ctx, iso.x + cameraX, iso.y + cameraY);
                }
            });
            const isoPlayer = toIso(player.x, player.y);
            player.draw(ctx, isoPlayer.x + cameraX, isoPlayer.y + cameraY);

            bullets.forEach(b => {
                const iso = toIso(b.x, b.y);
                const screenX = iso.x + cameraX;
                const screenY = iso.y + cameraY;
                ctx.fillStyle = b.color;
                ctx.beginPath();
                ctx.arc(screenX, screenY, 4, 0, Math.PI * 2);
                ctx.fill();
            });

            effects.forEach(e => {
                const iso = toIso(e.x, e.y);
                const screenX = iso.x + cameraX;
                const screenY = iso.y + cameraY;
                ctx.globalAlpha = e.life / 30;

                if (e.type === 'nova') {
                    ctx.fillStyle = e.color;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, e.radius * 20, 0, Math.PI * 2);
                    ctx.fill();
                } else if (e.type === 'levelup') {
                    ctx.strokeStyle = e.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(screenX, screenY + 10, e.radius * 20, e.radius * 10, 0, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (e.type === 'lightning') {
                    if (e.x1 !== undefined && e.x2 !== undefined) {
                        const start = toIso(e.x1, e.y1);
                        const end = toIso(e.x2, e.y2);
                        ctx.strokeStyle = e.color || '#8888ff';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(start.x + cameraX, start.y + cameraY);
                        ctx.lineTo(end.x + cameraX, end.y + cameraY);
                        ctx.stroke();
                    } else {
                        ctx.strokeStyle = '#ffff00';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(screenX, screenY);
                        ctx.lineTo(screenX + (Math.random() - 0.5) * 50, screenY - 50 + (Math.random() - 0.5) * 50);
                        ctx.stroke();
                    }
                }
            });
            effects = effects.filter(e => e.life > 0);

            floatingTexts.forEach(ft => {
                const iso = toIso(ft.x, ft.y);
                const screenX = iso.x + cameraX;
                const screenY = iso.y + cameraY - 40 + (60 - ft.life);
                ctx.fillStyle = ft.color;
                ctx.font = `bold ${ft.size}px Arial`;
                ctx.fillText(ft.text, screenX, screenY);
                ft.life--;
            });
            floatingTexts = floatingTexts.filter(ft => ft.life > 0);

            ctx.globalAlpha = 1.0;
        }

        const MATERIALS = [
            { name: 'Iron Ore', color: '#aaaaaa', value: 5 },
            { name: 'Wood', color: '#8b4513', value: 2 },
            { name: 'Leather', color: '#cd853f', value: 5 },
            { name: 'Magic Dust', color: '#00ffff', value: 20 }
        ];

        function spawnItem(x, y, isBossDrop = false) {
            let type = Math.floor(Math.random() * 10); // 0-3: weapons/hp, 4-6: equip, 7: gold, 8: material, 9: scroll

            if (isBossDrop) {
                type = Math.floor(Math.random() * 3) + 4; // 4-6 (Weapon, Armor, Acc)
            }

            let item = { x, y, type, life: 600 };

            if (type <= 3) {
                if (Math.random() < 0.2) {
                    const equip = generateEquipment('weapon', isBossDrop);
                    item = {
                        ...item,
                        ...equip,
                        color: equip.color, type: 4
                    };
                } else {
                    item.type = 0; // HP Potion fallback
                    item.color = '#00ff00';
                }
            } else if (type === 4) {
                const equip = generateEquipment('weapon', isBossDrop);
                item = {
                    ...item,
                    ...equip,
                    color: equip.color
                };
            } else if (type === 5) {
                const equip = generateEquipment('armor', isBossDrop);
                item = {
                    ...item,
                    ...equip,
                    color: equip.color
                };
            } else if (type === 6) {
                const equip = generateEquipment('accessory', isBossDrop);
                item = {
                    ...item,
                    ...equip,
                    color: equip.color
                };
            } else if (type === 7) {
                item.color = '#ffd700'; // Gold
            } else if (type === 8) {
                // Material
                const mat = MATERIALS[Math.floor(Math.random() * MATERIALS.length)];
                item = { ...item, name: mat.name, color: mat.color, stats: {}, slot: 'material', value: mat.value };
            } else if (type === 9) {
                // Return Scroll
                item = { ...item, name: 'Return Scroll', color: '#0000ff', stats: {}, slot: 'consumable', value: 10 };
            }

            items.push(item);
        }
        function generateEquipment(type, isBossDrop = false) {
            let rarity = Math.random();
            if (isBossDrop) rarity += 0.3;

            let quality = 1; // Common
            let color = '#ffffff';
            let prefix = 'Common';
            let statMult = 1;

            if (rarity > 0.98) {
                quality = 5; // Legendary
                color = '#ff8800'; // Orange
                prefix = 'Legendary';
                statMult = 3.0;
            } else if (rarity > 0.90) {
                quality = 4; // Epic
                color = '#800080'; // Purple
                prefix = 'Epic';
                statMult = 2.0;
            } else if (rarity > 0.75) {
                quality = 3; // Rare
                color = '#0000ff'; // Blue
                prefix = 'Rare';
                statMult = 1.5;
            } else if (rarity > 0.45) {
                quality = 2; // Uncommon
                color = '#00ff00'; // Green
                prefix = 'Uncommon';
                statMult = 1.2;
            }

            let weaponStats = null;
            let itemName = `${prefix} ${type.charAt(0).toUpperCase() + type.slice(1)}`;

            if (type === 'weapon') {
                const weaponTypes = Object.keys(player.WEAPONS).filter(k => k !== 'DEFAULT');
                const weaponKey = weaponTypes[Math.floor(Math.random() * weaponTypes.length)];
                weaponStats = { ...player.WEAPONS[weaponKey] };
                itemName = `${prefix} ${weaponStats.name}`;

                weaponStats.damageMult *= statMult;
                weaponStats.rate = Math.max(5, weaponStats.rate * (1 - (quality - 1) * 0.05)); // Slight speed buff for quality
            }

            const stats = {
                attack: type === 'weapon' ? Math.floor((Math.random() * 5 + 1) * statMult) : 0,
                defense: type === 'armor' ? Math.floor((Math.random() * 3 + 1) * statMult) : 0,
                speed: type === 'accessory' ? (Math.random() * 0.05 * quality) : 0, // Speed scales with quality directly
                maxHp: Math.floor((Math.random() * 20 + 10) * statMult),
                critRate: Math.random() * 0.01 * quality,
                critDamage: Math.random() * 0.05 * quality
            };

            return {
                name: itemName,
                stats,
                weaponStats,
                slot: type,
                quality,
                color
            };
        }

        function toggleStats() {
            const panel = document.getElementById('statPanel');
            panel.style.display = panel.style.display === 'flex' ? 'none' : 'flex';
            if (panel.style.display === 'flex') {
                updateStatUI();
                updateInventoryUI();
            }
        }

        function switchTab(tabName) {
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(p => p.classList.remove('active'));
            const btn = document.querySelector(`.tab-btn[onclick="switchTab('${tabName}')"]`);
            if (btn) btn.classList.add('active');
            const panel = document.getElementById(`panel-${tabName}`);
            if (panel) panel.classList.add('active');
        }

        function increaseStat(stat) {
            if (player.statPoints > 0) {
                if (stat === 'attack') player.baseStats.attack += 1;
                else if (stat === 'speed') player.baseStats.speed += 0.1;
                else if (stat === 'critRate') player.baseStats.critRate += 0.01;
                else if (stat === 'critDamage') player.baseStats.critDamage += 0.1;
                else if (stat === 'maxHp') {
                    player.baseStats.maxHp += 10;
                    player.hp += 10;
                } else if (stat === 'defense') {
                    player.baseStats.defense += 1;
                }
                player.statPoints--;
                updateStatUI();
            }
        }

        // --- QUEST SYSTEM LOGIC ---

        function generateQuests() {
            availableQuests = [];
            for (let i = 0; i < 5; i++) {
                const id = Date.now() + i;
                const difficulty = Math.floor(Math.random() * 5) + 1;
                const isKill = Math.random() < 0.6;
                let quest;

                if (isKill) {
                    const amount = 5 + difficulty * 2;
                    quest = new Quest(id, 'kill', 'any', 'Enemies', amount, difficulty);
                } else {
                    const amount = 3 + difficulty;
                    quest = new Quest(id, 'collect', 'material', 'Materials', amount, difficulty);
                }
                availableQuests.push(quest);
            }
        }

        function toggleQuest() {
            const panel = document.getElementById('questBoard');
            if (panel.style.display === 'none') {
                if (availableQuests.length === 0) generateQuests();
                updateQuestBoardUI();
                panel.style.display = 'block';
            } else {
                panel.style.display = 'none';
            }
        }

        function updateQuestBoardUI() {
            const list = document.getElementById('questList');
            list.innerHTML = '';
            availableQuests.forEach((q, index) => {
                const div = document.createElement('div');
                div.style.cssText = 'background:#222; padding:10px; border:1px solid #444; display:flex; justify-content:space-between; align-items:center;';

                let difficultyStars = '★'.repeat(q.difficulty);
                let rewardText = q.reward.type === 'gold' ? `${q.reward.value} G` : `${q.reward.itemName}`;

                div.innerHTML = `
                    <div>
                        <div style="font-weight:bold; color:#ffd700;">${q.type === 'kill' ? 'Slaughter' : 'Gathering'} ${difficultyStars}</div>
                        <div style="font-size:12px; color:#aaa;">Objective: ${q.type === 'kill' ? 'Kill' : 'Collect'} ${q.amount} ${q.targetName}</div>
                        <div style="font-size:12px; color:#0f0;">Reward: ${rewardText}</div>
                    </div>
                `;

                // Check if already accepted
                const isAccepted = activeQuests.some(aq => aq.id === q.id);
                if (isAccepted) {
                    div.innerHTML += `<button style="padding:5px 10px; background:#444; border:none; color:#888; cursor:not-allowed;">ACCEPTED</button>`;
                } else if (activeQuests.length >= MAX_ACTIVE_QUESTS) {
                    div.innerHTML += `<button style="padding:5px 10px; background:#444; border:none; color:#888; cursor:not-allowed;">FULL</button>`;
                } else {
                    div.innerHTML += `<button onclick="acceptQuest(${index})" style="padding:5px 10px; background:#0088ff; border:none; color:#fff; cursor:pointer;">ACCEPT</button>`;
                }
                list.appendChild(div);
            });
        }

        function acceptQuest(index) {
            if (activeQuests.length >= MAX_ACTIVE_QUESTS) return;
            const quest = availableQuests[index];
            if (activeQuests.some(aq => aq.id === quest.id)) return;

            activeQuests.push(quest);
            updateQuestBoardUI();
            updateQuestLogUI();
            updateHUDQuestList();
            spawnFloatingText(player.x, player.y, "Quest Accepted!", '#00ff00', 30);
        }

        function toggleQuestLog() {
            const panel = document.getElementById('questLog');
            if (panel.style.display === 'none') {
                updateQuestLogUI();
                panel.style.display = 'block';
            } else {
                panel.style.display = 'none';
            }
        }

        function updateQuestLogUI() {
            const list = document.getElementById('activeQuestList');
            document.getElementById('questCount').innerText = activeQuests.length;
            list.innerHTML = '';

            if (activeQuests.length === 0) {
                list.innerHTML = '<div style="color:#666; text-align:center;">No active quests.</div>';
                return;
            }

            activeQuests.forEach((q, index) => {
                const div = document.createElement('div');
                div.style.cssText = 'background:#222; padding:10px; border:1px solid #444;';

                const isComplete = q.current >= q.amount;
                const statusColor = isComplete ? '#00ff00' : '#fff';
                const statusText = isComplete ? 'COMPLETED' : 'IN PROGRESS';
                let rewardText = q.reward.type === 'gold' ? `${q.reward.value} G` : `${q.reward.itemName}`;

                let buttons = `<button onclick="abandonQuest(${index})" style="padding:5px; background:#882222; border:none; color:#fff; cursor:pointer; margin-right:5px;">CANCEL</button>`;
                if (isComplete) {
                    buttons = `<button onclick="completeQuest(${index})" style="padding:5px 10px; background:#00ff00; border:none; color:#000; cursor:pointer; font-weight:bold;">CLAIM REWARD</button>`;
                }

                div.innerHTML = `
                    <div style="display:flex; justify-content:space-between; margin-bottom:5px;">
                        <span style="color:${statusColor}; font-weight:bold;">${q.type === 'kill' ? 'Defeat Enemies' : 'Collect Materials'}</span>
                        <span style="color:#aaa;">${statusText}</span>
                    </div>
                    <div style="font-size:14px; margin-bottom:5px;">Progress: ${q.current} / ${q.amount}</div>
                    <div style="font-size:12px; color:#ffd700; margin-bottom:10px;">Reward: ${rewardText}</div>
                    <div style="text-align:right;">${buttons}</div>
                `;
                list.appendChild(div);
            });
        }

        function abandonQuest(index) {
            activeQuests.splice(index, 1);
            updateQuestLogUI();
            updateHUDQuestList();
            updateQuestBoardUI(); // Refresh status on board if open
        }

        function completeQuest(index) {
            const q = activeQuests[index];
            // Give Reward
            if (q.reward.type === 'gold') {
                player.gold += q.reward.value;
                spawnFloatingText(player.x, player.y, `+${q.reward.value} G`, '#ffd700', 40);
            } else {
                // Item reward logic - simple fallback
                spawnItem(player.x, player.y);
                spawnFloatingText(player.x, player.y, `Quest Item!`, '#ffa500', 40);
            }

            activeQuests.splice(index, 1);

            // Refresh quest board to generate new quest
            generateQuests(); // Refresh all

            updateQuestLogUI();
            updateHUDQuestList();
            if (document.getElementById('questBoard').style.display === 'block') {
                updateQuestBoardUI();
            }

            alert(`Quest Complete!\nReward: ${q.reward.type === 'gold' ? q.reward.value + ' Gold' : q.reward.itemName}`);
        }

        function updateHUDQuestList() {
            const hud = document.getElementById('questHUD');
            const list = document.getElementById('hudQuestList');
            if (activeQuests.length === 0) {
                hud.style.display = 'none';
                return;
            }
            hud.style.display = 'block';
            list.innerHTML = '';
            activeQuests.forEach(q => {
                const color = q.current >= q.amount ? '#00ff00' : '#fff';
                list.innerHTML += `<div style="color:${color}; margin-bottom:2px;">${q.type === 'kill' ? 'Kill' : 'Collect'}: ${q.current}/${q.amount}</div>`;
            });
        }

        // Global Quest Update Hook
        function onQuestEvent(type, target) {
            let updated = false;
            activeQuests.forEach(q => {
                if (q.status !== 'completed' && q.type === type) {
                    if (type === 'kill') {
                        q.current++;
                        updated = true;
                    } else if (type === 'collect') {
                        q.current++;
                        updated = true;
                    }
                    if (q.current > q.amount) q.current = q.amount;
                }
            });
            if (updated) {
                updateHUDQuestList();
                if (document.getElementById('questLog').style.display === 'block') updateQuestLogUI();
            }
        }

        function updateStatUI() {
            document.getElementById('playerLevel').innerText = player.level;
            document.getElementById('playerXP').innerText = `${Math.floor(player.xp)}/${player.xpToNextLevel}`;
            document.getElementById('playerHP').innerText = `${Math.floor(player.hp)}/${player.stats.maxHp}`;
            document.getElementById('playerEnergy').innerText = `${Math.floor(player.energy)}/${player.maxEnergy}`;
            document.getElementById('playerAttack').innerText = player.stats.attack.toFixed(1);
            document.getElementById('playerSpeed').innerText = player.stats.speed.toFixed(2);
            document.getElementById('playerDefense').innerText = player.stats.defense.toFixed(0);
            document.getElementById('playerCritRate').innerText = (player.stats.critRate * 100).toFixed(1) + '%';
            document.getElementById('playerCritDamage').innerText = (player.stats.critDamage * 100).toFixed(0) + '%';
            document.getElementById('playerMaxHp').innerText = player.stats.maxHp;
            document.getElementById('statPoints').innerText = player.statPoints;
            document.getElementById('statButtons').style.display = player.statPoints > 0 ? 'block' : 'none';
            updateSkillUI();
            updateTalentUI();
        }

        function unlockSkill(index) {
            if (player.unlockSkill(index)) {
                updateSkillUI();
                updateHUD();
            }
        }

        function updateSkillUI() {
            const grid = document.getElementById('skillGrid');
            grid.innerHTML = '';
            document.getElementById('skillPoints').innerText = player.skillPoints;

            player.SKILLS.forEach((skill, index) => {
                const card = document.createElement('div');
                card.className = `skill-card ${skill.unlocked ? 'unlocked' : 'locked'}`;
                const btnClass = (player.skillPoints > 0 && player.level >= skill.levelReq && !skill.unlocked) ? 'skill-btn' : 'skill-btn disabled';
                const btnText = skill.unlocked ? 'UNLOCKED' : (player.level >= skill.levelReq ? 'UNLOCK' : `LVL ${skill.levelReq}`);
                const btnAction = (player.skillPoints > 0 && player.level >= skill.levelReq && !skill.unlocked) ? `onclick="unlockSkill(${index})"` : '';

                card.innerHTML = `<div class="skill-icon">${skill.icon}</div>
                                  <div class="skill-info" style="width:100%">
                                      <div class="skill-name">${skill.name}</div>
                                      <div class="skill-desc">${skill.desc}</div>
                                  </div>
                                  <button class="${btnClass}" ${btnAction}>${btnText}</button>`;
                grid.appendChild(card);
            });
        }

        function updateTalentUI() {
            const list = document.getElementById('talentList');
            list.innerHTML = '';
            document.getElementById('talentPoints').innerText = player.talentPoints;

            player.TALENTS.forEach((talent, index) => {
                const row = document.createElement('div');
                row.className = 'talent-row';
                const canUpgrade = player.talentPoints > 0 && talent.level < talent.maxLevel;
                const btnClass = canUpgrade ? 'talent-btn' : 'talent-btn disabled';
                const btnAction = canUpgrade ? `onclick="upgradeTalent(${index})"` : '';

                row.innerHTML = `<div class="talent-info">
                                     <div class="talent-name">${talent.name} <span style="color:#666; font-size:12px;">(Lvl ${talent.level}/${talent.maxLevel})</span></div>
                                     <div class="talent-desc">${talent.desc}</div>
                                 </div>
                                 <button class="${btnClass}" ${btnAction}>UPGRADE</button>`;
                list.appendChild(row);
            });
        }

        function upgradeTalent(index) {
            if (player.upgradeTalent(index)) {
                updateTalentUI();
                updateStatUI();
            }
        }

        function switchInventoryTab(tab) {
            currentInventoryTab = tab;
            document.querySelectorAll('.inv-tab-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.innerText.toLowerCase().includes(tab) || (tab === 'all' && btn.innerText === 'All')) {
                    btn.classList.add('active');
                }
            });
            updateInventoryUI();
        }


        function getItemValue(item) {
            if (item.type === 7) return 1; // Consumable/Ammo
            if (item.type === 8) return item.value || 5; // Material
            if (item.type === 9) return 10; // Return Scroll
            if (item.quality === 3) return 200; // Legendary
            if (item.quality === 2) return 50;  // Rare
            return 10; // Common
        }

        function sellItem(index) {
            const item = player.inventory[index];
            if (!item) return;

            let value = getItemValue(item);

            player.gold += value;
            player.inventory.splice(index, 1);
            spawnFloatingText(player.x, player.y, `+${value} G`, '#ffd700', 20);
            updateInventoryUI();
            updateStatUI();
        }

        function useItem(index) {
            const item = player.inventory[index];
            if (!item) return;

            if (item.type === 9) { // Return Scroll
                if (currentMapType === 'dungeon') {
                    lastDungeonStage = stage;
                    returnPortalOpen = true; // Open return portal

                    currentMapType = 'town';
                    stage = 1;
                    resetGame(true);
                    spawnFloatingText(player.x, player.y, "Teleporting...", '#00ffff', 30);
                    player.inventory.splice(index, 1);
                    updateInventoryUI();
                } else {
                    spawnFloatingText(player.x, player.y, "Already in Town", '#ff0000', 20);
                }
            }
        }

        // --- QUEST SYSTEM LOGIC ---

        function generateQuests() {
            availableQuests = [];
            for (let i = 0; i < 5; i++) {
                const id = Date.now() + i;
                const difficulty = Math.floor(Math.random() * 5) + 1;
                const isKill = Math.random() < 0.6;
                let quest;

                if (isKill) {
                    const amount = 5 + difficulty * 2;
                    quest = new Quest(id, 'kill', 'any', 'Enemies', amount, difficulty);
                } else {
                    const amount = 3 + difficulty;
                    quest = new Quest(id, 'collect', 'material', 'Materials', amount, difficulty);
                }
                availableQuests.push(quest);
            }
        }

        function toggleQuest() {
            const panel = document.getElementById('questBoard');
            if (panel.style.display === 'none') {
                if (availableQuests.length === 0) generateQuests();
                updateQuestBoardUI();
                panel.style.display = 'block';
            } else {
                panel.style.display = 'none';
            }
        }

        function updateQuestBoardUI() {
            const list = document.getElementById('questList');
            list.innerHTML = '';
            availableQuests.forEach((q, index) => {
                const div = document.createElement('div');
                div.style.cssText = 'background:#222; padding:10px; border:1px solid #444; display:flex; justify-content:space-between; align-items:center;';

                let difficultyStars = '★'.repeat(q.difficulty);
                let rewardText = q.reward.type === 'gold' ? `${q.reward.value} G` : `${q.reward.itemName}`;

                div.innerHTML = `
                    <div>
                        <div style="font-weight:bold; color:#ffd700;">${q.type === 'kill' ? 'Slaughter' : 'Gathering'} ${difficultyStars}</div>
                        <div style="font-size:12px; color:#aaa;">Objective: ${q.type === 'kill' ? 'Kill' : 'Collect'} ${q.amount} ${q.targetName}</div>
                        <div style="font-size:12px; color:#0f0;">Reward: ${rewardText}</div>
                    </div>
                `;

                // Check if already accepted
                const isAccepted = activeQuests.some(aq => aq.id === q.id);
                if (isAccepted) {
                    div.innerHTML += `<button style="padding:5px 10px; background:#444; border:none; color:#888; cursor:not-allowed;">ACCEPTED</button>`;
                } else if (activeQuests.length >= MAX_ACTIVE_QUESTS) {
                    div.innerHTML += `<button style="padding:5px 10px; background:#444; border:none; color:#888; cursor:not-allowed;">FULL</button>`;
                } else {
                    div.innerHTML += `<button onclick="acceptQuest(${index})" style="padding:5px 10px; background:#0088ff; border:none; color:#fff; cursor:pointer;">ACCEPT</button>`;
                }
                list.appendChild(div);
            });
        }

        function acceptQuest(index) {
            if (activeQuests.length >= MAX_ACTIVE_QUESTS) return;
            const quest = availableQuests[index];
            if (activeQuests.some(aq => aq.id === quest.id)) return;

            activeQuests.push(quest);
            updateQuestBoardUI();
            updateQuestLogUI();
            updateHUDQuestList();
            spawnFloatingText(player.x, player.y, "Quest Accepted!", '#00ff00', 30);
        }

        function toggleQuestLog() {
            const panel = document.getElementById('questLog');
            if (panel.style.display === 'none') {
                updateQuestLogUI();
                panel.style.display = 'block';
            } else {
                panel.style.display = 'none';
            }
        }

        function updateQuestLogUI() {
            const list = document.getElementById('activeQuestList');
            document.getElementById('questCount').innerText = activeQuests.length;
            list.innerHTML = '';

            if (activeQuests.length === 0) {
                list.innerHTML = '<div style="color:#666; text-align:center;">No active quests.</div>';
                return;
            }

            activeQuests.forEach((q, index) => {
                const div = document.createElement('div');
                div.style.cssText = 'background:#222; padding:10px; border:1px solid #444;';

                const isComplete = q.current >= q.amount;
                const statusColor = isComplete ? '#00ff00' : '#fff';
                const statusText = isComplete ? 'COMPLETED' : 'IN PROGRESS';
                let rewardText = q.reward.type === 'gold' ? `${q.reward.value} G` : `${q.reward.itemName}`;

                let buttons = `<button onclick="abandonQuest(${index})" style="padding:5px; background:#882222; border:none; color:#fff; cursor:pointer; margin-right:5px;">CANCEL</button>`;
                if (isComplete) {
                    buttons = `<button onclick="completeQuest(${index})" style="padding:5px 10px; background:#00ff00; border:none; color:#000; cursor:pointer; font-weight:bold;">CLAIM REWARD</button>`;
                }

                div.innerHTML = `
                    <div style="display:flex; justify-content:space-between; margin-bottom:5px;">
                        <span style="color:${statusColor}; font-weight:bold;">${q.type === 'kill' ? 'Defeat Enemies' : 'Collect Materials'}</span>
                        <span style="color:#aaa;">${statusText}</span>
                    </div>
                    <div style="font-size:14px; margin-bottom:5px;">Progress: ${q.current} / ${q.amount}</div>
                    <div style="font-size:12px; color:#ffd700; margin-bottom:10px;">Reward: ${rewardText}</div>
                    <div style="text-align:right;">${buttons}</div>
                `;
                list.appendChild(div);
            });
        }

        function abandonQuest(index) {
            activeQuests.splice(index, 1);
            updateQuestLogUI();
            updateHUDQuestList();
            updateQuestBoardUI(); // Refresh status on board if open
        }

        function completeQuest(index) {
            const q = activeQuests[index];
            // Give Reward
            if (q.reward.type === 'gold') {
                player.gold += q.reward.value;
                spawnFloatingText(player.x, player.y, `+${q.reward.value} G`, '#ffd700', 40);
            } else {
                // Item reward logic - simple fallback
                spawnItem(player.x, player.y);
                spawnFloatingText(player.x, player.y, `Quest Item!`, '#ffa500', 40);
            }

            activeQuests.splice(index, 1);

            // Refresh quest board to generate new quest
            generateQuests(); // Or replace the specific one? Requirement says "NPC刷新及隨機生成新任務". Can just regenerate all or replace.

            updateQuestLogUI();
            updateHUDQuestList();
            if (document.getElementById('questBoard').style.display === 'block') {
                updateQuestBoardUI();
            }

            alert(`Quest Complete!\nReward: ${q.reward.type === 'gold' ? q.reward.value + ' Gold' : q.reward.itemName}`);
        }

        function updateHUDQuestList() {
            const hud = document.getElementById('questHUD');
            const list = document.getElementById('hudQuestList');
            if (activeQuests.length === 0) {
                hud.style.display = 'none';
                return;
            }
            hud.style.display = 'block';
            list.innerHTML = '';
            activeQuests.forEach(q => {
                const color = q.current >= q.amount ? '#00ff00' : '#fff';
                list.innerHTML += `<div style="color:${color}; margin-bottom:2px;">${q.type === 'kill' ? 'Kill' : 'Collect'}: ${q.current}/${q.amount}</div>`;
            });
        }

        // Global Quest Update Hook
        function onQuestEvent(type, target) {
            let updated = false;
            activeQuests.forEach(q => {
                if (q.status !== 'completed' && q.type === type) {
                    if (type === 'kill') {
                        q.current++;
                        updated = true;
                    } else if (type === 'collect') {
                        q.current++;
                        updated = true;
                    }
                    if (q.current > q.amount) q.current = q.amount;
                }
            });
            if (updated) {
                updateHUDQuestList();
                if (document.getElementById('questLog').style.display === 'block') updateQuestLogUI();
            }
        }

        function updateInventoryUI() {
            const list = document.getElementById('inventoryList');
            list.innerHTML = '';
            const filteredInventory = player.inventory.map((item, index) => ({ item, index }))
                .filter(({ item }) => {
                    if (currentInventoryTab === 'all') return true;
                    if (currentInventoryTab === 'material') {
                        return item.slot === 'material' || item.slot === 'consumable';
                    }
                    return item.slot === currentInventoryTab;
                });

            if (filteredInventory.length === 0) {
                list.innerHTML = '<p style="color:#666;">No items in this category.</p>';
            } else {
                filteredInventory.forEach(({ item, index }) => {
                    const div = document.createElement('div');
                    div.className = 'inv-item';
                    div.onmouseenter = (e) => showItemTooltip(item, e);
                    div.onmouseleave = hideItemTooltip;
                    div.onmousemove = (e) => moveItemTooltip(e);

                    let statsStr = '';
                    if (item.stats.attack) statsStr += `ATK: +${item.stats.attack} `;
                    if (item.stats.speed) statsStr += `SPD: +${item.stats.speed.toFixed(2)} `;
                    if (item.stats.maxHp) statsStr += `HP: +${item.stats.maxHp} `;
                    if (item.stats.defense) statsStr += `DEF: +${item.stats.defense} `;
                    if (item.stats.critRate) statsStr += `CRIT %: +${(item.stats.critRate * 100).toFixed(1)}% `;
                    if (item.stats.critDamage) statsStr += `CRIT DMG: +${item.stats.critDamage.toFixed(1)} `;

                    let actionBtn = `<button class="inv-btn" onclick="equipItem(${index})" style="flex:1;">EQUIP</button>`;
                    if (item.type === 8) { // Material
                        actionBtn = `<button class="inv-btn" style="flex:1; background:#444; cursor:default;">MATERIAL</button>`;
                    } else if (item.type === 9) { // Return Scroll
                        actionBtn = `<button class="inv-btn" onclick="useItem(${index})" style="flex:1; background:#0000aa;">USE</button>`;
                    }

                    div.innerHTML = `<div>
                                         <span class="inv-name" style="color:${item.color}">${item.name}</span>
                                         <span style="color:#666; font-size:10px;">${statsStr}</span>
                                     </div>
                                     <div style="display:flex; gap:5px; margin-top:auto;">
                                         ${actionBtn}
                                         <button class="inv-btn" onclick="sellItem(${index})" style="flex:1; background:#882222;">SELL (${getItemValue(item)}G)</button>
                                     </div>`;
                    list.appendChild(div);
                });
            }

            const eqWeapon = document.getElementById('eq-weapon');
            const eqArmor = document.getElementById('eq-armor');
            const eqAccessory = document.getElementById('eq-accessory');

            if (player.equipment.weapon) {
                eqWeapon.innerHTML = `<span style="color:${player.equipment.weapon.color}">${player.equipment.weapon.name}</span><button class="unequip-btn" onclick="unequipItem('weapon')">X</button>`;
            } else {
                eqWeapon.textContent = 'None';
            }

            if (player.equipment.armor) {
                eqArmor.innerHTML = `<span style="color:${player.equipment.armor.color}">${player.equipment.armor.name}</span><button class="unequip-btn" onclick="unequipItem('armor')">X</button>`;
            } else {
                eqArmor.textContent = 'None';
            }

            if (player.equipment.accessory) {
                eqAccessory.innerHTML = `<span style="color:${player.equipment.accessory.color}">${player.equipment.accessory.name}</span><button class="unequip-btn" onclick="unequipItem('accessory')">X</button>`;
            } else {
                eqAccessory.textContent = 'None';
            }
        }

        const tooltip = document.getElementById('itemTooltip');

        function showItemTooltip(item, e) {
            tooltip.style.display = 'block';
            moveItemTooltip(e);
            const equipped = player.equipment[item.slot];
            let content = `<div class="tooltip-header" style="color:${item.color}">${item.name}</div>`;

            const compare = (label, val, eqVal, isPercent = false) => {
                if (!val && !eqVal) return '';
                const v = val || 0;
                const ev = eqVal || 0;
                const diff = v - ev;
                const diffStr = isPercent ? (diff * 100).toFixed(1) + '%' : diff.toFixed(1);
                const valStr = isPercent ? (v * 100).toFixed(1) + '%' : v.toFixed(1);

                let diffHtml = '';
                if (diff > 0.001) diffHtml = `<span class="stat-better"> (+${diffStr} ??</span>`;
                else if (diff < -0.001) diffHtml = `<span class="stat-worse"> (${diffStr} ??</span>`;

                return `<div class="tooltip-stat"><span>${label}: ${valStr}</span>${diffHtml}</div>`;
            };

            const eqStats = equipped ? equipped.stats : {};
            content += compare('Attack', item.stats.attack, eqStats.attack);
            content += compare('Defense', item.stats.defense, eqStats.defense);
            content += compare('Speed', item.stats.speed, eqStats.speed);
            content += compare('Max HP', item.stats.maxHp, eqStats.maxHp);
            content += compare('Crit Rate', item.stats.critRate, eqStats.critRate, true);
            content += compare('Crit Dmg', item.stats.critDamage, eqStats.critDamage, true);

            if (equipped) {
                content += `<div style="margin-top:5px; font-size:10px; color:#aaa;">Comparision with equipped ${equipped.name}</div>`;
            } else {
                content += `<div style="margin-top:5px; font-size:10px; color:#aaa;">No item equipped in this slot</div>`;
            }
            tooltip.innerHTML = content;
        }

        function hideItemTooltip() {
            tooltip.style.display = 'none';
        }

        function moveItemTooltip(e) {
            tooltip.style.left = (e.clientX + 15) + 'px';
            tooltip.style.top = (e.clientY + 15) + 'px';
        }

        function equipItem(index) {
            const item = player.inventory[index];
            const slot = item.slot;
            if (!slot) return;

            if (player.equipment[slot]) {
                player.inventory.push(player.equipment[slot]);
            }
            player.equipment[slot] = item;
            player.inventory.splice(index, 1);
            updateInventoryUI();
            updateStatUI();
        }

        function unequipItem(slot) {
            if (player.equipment[slot]) {
                player.inventory.push(player.equipment[slot]);
                player.equipment[slot] = null;
                updateInventoryUI();
                updateStatUI();
            }
        }

        function spawnFloatingText(x, y, text, color, size) {
            floatingTexts.push({ x, y, text, color, size, life: 60 });
        }

        function updateFog() {
            const range = 8;
            for (let y = Math.floor(player.y - range); y <= Math.floor(player.y + range); y++) {
                for (let x = Math.floor(player.x - range); x <= Math.floor(player.x + range); x++) {
                    if (y >= 0 && y < MAP_SIZE && x >= 0 && x < MAP_SIZE) {
                        if (Math.sqrt((x - player.x) ** 2 + (y - player.y) ** 2) < range) {
                            if (explored[y]) explored[y][x] = true;
                        }
                    }
                }
            }
        }





        function updateHUD() {
            document.getElementById('hp-text').innerText = `${Math.floor(player.hp)}/${player.stats.maxHp}`;
            document.getElementById('hp-bar-fill').style.width = `${(player.hp / player.stats.maxHp) * 100}%`;
            document.getElementById('playerGold').innerText = player.gold;

            const xpPercent = (player.xp / player.xpToNextLevel) * 100;
            document.getElementById('xp-bar-fill').style.width = xpPercent + '%';

            const energyPercent = (player.energy / player.maxEnergy) * 100;
            document.getElementById('energy-bar-fill').style.width = energyPercent + '%';

            player.SKILLS.forEach((skill, index) => {
                let id = index + 1;
                if (index === 5) id = 'space';
                const cdEl = document.getElementById(`cd-${id}`);
                if (cdEl) {
                    const percent = (skill.cooldown / skill.maxCooldown) * 100;
                    cdEl.style.height = percent + '%';
                }
            });
        }

        function toggleMerchant() {
            const panel = document.getElementById('merchantPanel');
            panel.style.display = panel.style.display === 'flex' ? 'none' : 'flex';
        }





        function buyItem(type) {
            let cost = 0;
            if (type === 'potion') cost = 50;
            else if (type === 'weapon') cost = 200;
            else if (type === 'armor') cost = 150;
            else if (type === 'accessory') cost = 150;

            if (player.gold >= cost) {
                player.gold -= cost;
                spawnFloatingText(player.x, player.y, `-${cost} G`, '#ffd700', 20);

                if (type === 'potion') {
                    player.hp = Math.min(player.hp + 50, player.stats.maxHp);
                    spawnFloatingText(player.x, player.y, "+50 HP", '#0f0', 20);
                } else {
                    let itemType = 4;
                    let itemColor = '#ffffff';
                    if (type === 'weapon') { itemType = 4; itemColor = '#00ffff'; }
                    if (type === 'armor') { itemType = 5; itemColor = '#ff00ff'; }
                    if (type === 'accessory') { itemType = 6; itemColor = '#ffffff'; }

                    const item = generateEquipment(type, false);
                    const newItem = {
                        type: itemType,
                        color: itemColor,
                        ...item
                    };
                    player.inventory.push(newItem);
                    spawnFloatingText(player.x, player.y, "ITEM BOUGHT", '#fff', 20);
                    updateInventoryUI();
                }
            } else {
                spawnFloatingText(player.x, player.y, "Not Enough Gold", '#f00', 20);
            }
        }


        const RECIPES = [
            { id: 'sword', name: 'Iron Sword', type: 'weapon', materials: { 'Iron Ore': 3, 'Wood': 1 } },
            { id: 'armor', name: 'Leather Armor', type: 'armor', materials: { 'Leather': 3, 'Iron Ore': 1 } },
            { id: 'accessory', name: 'Magic Ring', type: 'accessory', materials: { 'Magic Dust': 3 } }
        ];

        function toggleCrafting() {
            const panel = document.getElementById('craftingPanel');
            panel.style.display = panel.style.display === 'flex' ? 'none' : 'flex';
            if (panel.style.display === 'flex') {
                renderCraftingUI();
            }
        }

        function renderCraftingUI() {
            const list = document.getElementById('craftingList');
            list.innerHTML = '';

            RECIPES.forEach(recipe => {
                const div = document.createElement('div');
                div.style.background = 'rgba(255, 255, 255, 0.1)';
                div.style.padding = '10px';
                div.style.borderRadius = '5px';
                div.style.display = 'flex';
                div.style.justifyContent = 'space-between';
                div.style.alignItems = 'center';

                let matStr = '';
                let canCraft = true;
                for (const [matName, count] of Object.entries(recipe.materials)) {
                    const playerHas = player.inventory.filter(i => i.name === matName).length;
                    const color = playerHas >= count ? '#00ff00' : '#ff0000';
                    if (playerHas < count) canCraft = false;
                    matStr += `<div style="font-size:12px; color:${color};">${matName}: ${playerHas}/${count}</div>`;
                }

                div.innerHTML = `
                    <div>
                        <div style="font-weight:bold; color:#ff8800;">${recipe.name}</div>
                        <div style="display:flex; gap:10px; margin-top:5px;">${matStr}</div>
                    </div>
                    <button onclick="craftItem('${recipe.id}')" style="padding:5px 10px; background:${canCraft ? '#ff8800' : '#444'}; border:none; color:white; cursor:${canCraft ? 'pointer' : 'not-allowed'};" ${canCraft ? '' : 'disabled'}>CRAFT</button>
                `;
                list.appendChild(div);
            });
        }

        function craftItem(recipeId) {
            const recipe = RECIPES.find(r => r.id === recipeId);
            if (!recipe) return;

            // Check materials again
            for (const [matName, count] of Object.entries(recipe.materials)) {
                const playerHas = player.inventory.filter(i => i.name === matName).length;
                if (playerHas < count) return;
            }

            // Consume materials
            for (const [matName, count] of Object.entries(recipe.materials)) {
                for (let i = 0; i < count; i++) {
                    const idx = player.inventory.findIndex(item => item.name === matName);
                    if (idx !== -1) player.inventory.splice(idx, 1);
                }
            }

            // Generate Item
            let newItem = generateEquipment(recipe.type);
            newItem.name = `Crafted ${newItem.name}`;
            newItem.quality = 2;
            newItem.color = '#00ff00';
            newItem.stats.attack += 2;
            newItem.stats.defense += 2;

            player.inventory.push(newItem);
            spawnFloatingText(player.x, player.y, "Crafted!", '#ff8800', 30);
            renderCraftingUI();
            updateInventoryUI();
        }
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            update();
            draw();
            requestAnimationFrame(animate);
        }

        try {
            console.log("Game Version: Quest System Implemented");
            resetGame();
            document.getElementById('tutorialPanel').style.display = 'flex';
            animate();
        } catch (e) {
            console.error("Game Init Error:", e);
            alert("Game Init Error: " + e.message);
        }
    </script>
</body>

</html>